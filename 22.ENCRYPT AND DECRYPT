#include <stdio.h>

// Initial permutation table for S-DES
const int IP[] = {2, 6, 3, 1, 4, 8, 5, 7};

// Inverse initial permutation table for S-DES
const int IP_inv[] = {4, 1, 3, 5, 7, 2, 8, 6};

// Expansion permutation table for S-DES
const int EP[] = {4, 1, 2, 3, 2, 3, 4, 1};

// P4 permutation table for S-DES
const int P4[] = {2, 4, 3, 1};

// S-Boxes for S-DES
const int S0[4][4] = {
    {1, 0, 3, 2},
    {3, 2, 1, 0},
    {0, 2, 1, 3},
    {3, 1, 3, 2}
};

const int S1[4][4] = {
    {0, 1, 2, 3},
    {2, 0, 1, 3},
    {3, 0, 1, 0},
    {2, 1, 0, 3}
};

// Key generation for S-DES
void generateKeys(unsigned short key, unsigned char *K1, unsigned char *K2) {
    unsigned short perm10 = 0;
    unsigned short LS1, LS2, temp;
    int i;

    // Apply permutation P10
    for (i = 0; i < 10; i++) {
        perm10 <<= 1;
        perm10 |= (key >> (10 - IP[i])) & 0x01;
    }

    // Split into two parts
    LS1 = (perm10 & 0x1F) << 1; // Left shift by 1
    LS1 |= (perm10 >> 4) & 0x01; // Rotate last bit to first

    LS2 = (perm10 & 0x03FF) << 2; // Left shift by 2

    // Apply permutation P8 to get K1
    *K1 = 0;
    for (i = 0; i < 8; i++) {
        *K1 <<= 1;
        *K1 |= (LS1 >> (8 - P4[i])) & 0x01;
    }

    // Apply permutation P8 to get K2
    *K2 = 0;
    for (i = 0; i < 8; i++) {
        *K2 <<= 1;
        *K2 |= (LS2 >> (8 - P4[i])) & 0x01;
    }
}

// S-DES round function
unsigned char round(unsigned char R, unsigned char K) {
    unsigned char expandedR = 0;
    unsigned char S0_output, S1_output, temp;

    // Expand R using EP
    for (int i = 0; i < 8; i++) {
        expandedR <<= 1;
        expandedR |= (R >> (4 - EP[i])) & 0x01;
    }

    // XOR with K
    expandedR ^= K;

    // Split into two 4-bit parts
    temp = expandedR;
    expandedR >>= 4;
    temp &= 0x0F;

    // Apply S-Box S0
    S0_output = S0[expandedR][temp];

    // Apply S-Box S1
    expandedR = temp;
    temp = temp & 0x02;
    temp <<= 1;
    expandedR |= temp;
    S1_output = S1[expandedR][temp];

    // P4 permutation
    temp = S0_output;
    temp <<= 2;
    temp |= S1_output;

    for (int i = 0; i < 4; i++) {
        S0_output <<= 1;
        S0_output |= (temp >> (4 - P4[i])) & 0x01;
    }

    return S0_output;
}

// S-DES encryption
unsigned short encrypt(unsigned short plaintext, unsigned short key, unsigned char IV) {
    unsigned char K1, K2, temp;
    unsigned short ciphertext = 0;

    // Generate K1 and K2
    generateKeys(key, &K1, &K2);

    // Initial permutation (IP)
    for (int i = 0; i < 8; i++) {
        ciphertext <<= 1;
        ciphertext |= (plaintext >> (8 - IP[i])) & 0x01;
    }

    // XOR with IV for CBC mode
    ciphertext ^= IV;

    // Round 1
    temp = ciphertext >> 8; // Left part
    ciphertext <<= 8;
    ciphertext |= round(temp, K1);

    // Swap halves
    temp = ciphertext >> 8;
    ciphertext <<= 8;
    ciphertext |= temp;

    // Round 2
    temp = ciphertext >> 8; // Left part
    ciphertext <<= 8;
    ciphertext |= round(temp, K2);

    // Final permutation (IP^-1)
    temp = 0;
    for (int i = 0; i < 8; i++) {
        temp <<= 1;
        temp |= (ciphertext >> (8 - IP_inv[i])) & 0x01;
    }
    ciphertext = temp;

    return ciphertext;
}

// S-DES decryption
unsigned short decrypt(unsigned short ciphertext, unsigned short key, unsigned char IV) {
    unsigned char K1, K2, temp;
    unsigned short plaintext = 0;

    // Generate K1 and K2
    generateKeys(key, &K1, &K2);

    // Initial permutation (IP)
    for (int i = 0; i < 8; i++) {
        plaintext <<= 1;
        plaintext |= (ciphertext >> (8 - IP[i])) & 0x01;
    }

    // Round 1
    temp = plaintext >> 8; // Left part
    plaintext <<= 8;
    plaintext |= round(temp, K2);

    // Swap halves
    temp = plaintext >> 8;
    plaintext <<= 8;
    plaintext |= temp;

    // Round 2
    temp = plaintext >> 8; // Left part
    plaintext <<= 8;
    plaintext |= round(temp, K1);

    // Final permutation (IP^-1)
    temp = 0;
    for (int i = 0; i < 8; i++) {
        temp <<= 1;
        temp |= (plaintext >> (8 - IP_inv[i])) & 0x01;
    }
    plaintext = temp;

    // XOR with IV for CBC mode
    plaintext ^= IV;

    return plaintext;
}

int main() {
    unsigned short plaintext = 0b0000000100100011;
    unsigned short key = 0b0111111101;
    unsigned char IV = 0b10101010;

    printf("Plaintext:      %04x\n", plaintext);
    printf("Key:            %05x\n", key);
    printf("Initialization Vector (IV): %02x\n\n", IV);

    // Encryption
    unsigned short ciphertext = encrypt(plaintext, key, IV);
    printf("Encrypted:      %04x\n", ciphertext);

    // Decryption
    unsigned short decryptedtext = decrypt(ciphertext, key, IV);
    printf("Decrypted:      %04x\n", decryptedtext);

    return 0;
}
